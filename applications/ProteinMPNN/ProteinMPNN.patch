diff --git a/examples/script_example_1.py b/examples/script_example_1.py
new file mode 100644
index 0000000..93d04ac
--- /dev/null
+++ b/examples/script_example_1.py
@@ -0,0 +1,52 @@
+#!/usr/bin/env python
+# encoding: utf-8
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding scripts")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_monomers/pdbs")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_1_outputs")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input directory: {args.input}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+
+    # Run parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run protein folding script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
diff --git a/examples/script_example_2.py b/examples/script_example_2.py
new file mode 100644
index 0000000..dc43474
--- /dev/null
+++ b/examples/script_example_2.py
@@ -0,0 +1,66 @@
+#!/usr/bin/env python
+# encoding: utf-8
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding with assigned chains")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_2_outputs")
+    parser.add_argument('--chains_to_design', help="Chains to design (space-separated)", default="A B")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input data directory: {args.input}")
+    print(f"Chains to design: {args.chains_to_design}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+    path_for_assigned_chains = os.path.join(output_dir, "assigned_pdbs.jsonl")
+
+    # Run parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run chain assignment script
+    a = run([
+        'python', '../helper_scripts/assign_fixed_chains.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_assigned_chains,
+        '--chain_list', args.chains_to_design
+    ])
+    assert a.returncode == 0, "Error assigning fixed chains"
+
+    # Run protein folding script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--chain_id_jsonl', path_for_assigned_chains,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_3.py b/examples/script_example_3.py
new file mode 100644
index 0000000..83a21d3
--- /dev/null
+++ b/examples/script_example_3.py
@@ -0,0 +1,47 @@
+#!/usr/bin/env python
+# encoding: utf-8
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding on specific PDB and chains")
+    parser.add_argument('--pdb_path', help="Path to the PDB file", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/3HTN.pdb")
+    parser.add_argument('--chains_to_design', help="Chains to design (space-separated)", default="A")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_3_outputs")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Path to the PDB file: {args.pdb_path}")
+    print(f"Chains to design: {args.chains_to_design}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    pdb_path = args.pdb_path
+
+    # Run protein folding script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--pdb_path', pdb_path,
+        '--pdb_path_chains', args.chains_to_design,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_3_score_only.py b/examples/script_example_3_score_only.py
new file mode 100644
index 0000000..6308b96
--- /dev/null
+++ b/examples/script_example_3_score_only.py
@@ -0,0 +1,50 @@
+#!/usr/bin/env python
+# encoding: utf-8
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding and scoring on specific PDB and chains")
+    parser.add_argument('--pdb_path', help="Path to the PDB file", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/3HTN.pdb")
+    parser.add_argument('--chains_to_design', help="Chains to design (space-separated)", default="A")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_3_score_only_outputs")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--score_only', type=int, default=1, help="Score only without sequence generation")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Path to the PDB file: {args.pdb_path}")
+    print(f"Chains to design: {args.chains_to_design}")
+
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    pdb_path = args.pdb_path
+
+    # Run protein folding script with scoring only
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--pdb_path', pdb_path,
+        '--pdb_path_chains', args.chains_to_design,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--score_only', str(args.score_only),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_3_score_only_from_fasta.py b/examples/script_example_3_score_only_from_fasta.py
new file mode 100644
index 0000000..4bcaa23
--- /dev/null
+++ b/examples/script_example_3_score_only_from_fasta.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python
+# encoding: utf-8
+
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding and scoring from a FASTA file on specific PDB and chains")
+    parser.add_argument('--pdb_path', help="Path to the PDB file", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/3HTN.pdb")
+    parser.add_argument('--path_to_fasta', help="Path to the FASTA file", default="/ProteinMPNN/outputs/example_3_outputs/seqs/3HTN.fa")
+    parser.add_argument('--chains_to_design', help="Chains to design (space-separated)", default="A")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_3_score_only_from_fasta_outputs")
+    parser.add_argument('--num_seq_per_target', type=int, default=5, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--score_only', type=int, default=1, help="Score only without sequence generation")
+    parser.add_argument('--seed', type=int, default=13, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Path to the PDB file: {args.pdb_path}")
+    print(f"Path to the FASTA file: {args.path_to_fasta}")
+    print(f"Chains to design: {args.chains_to_design}")
+
+    # Print the input arguments for visibility
+    print(f"Path to the PDB file: {args.pdb_path}")
+    print(f"Path to the FASTA file: {args.path_to_fasta}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    pdb_path = args.pdb_path
+    path_to_fasta = args.path_to_fasta
+
+    # Run protein folding script with scoring only from FASTA
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--path_to_fasta', path_to_fasta,
+        '--pdb_path', pdb_path,
+        '--pdb_path_chains', args.chains_to_design,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--score_only', str(args.score_only),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
diff --git a/examples/script_example_4.py b/examples/script_example_4.py
new file mode 100644
index 0000000..96b211d
--- /dev/null
+++ b/examples/script_example_4.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python
+# encoding: utf-8
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding with fixed positions on specific chains")
+    parser.add_argument('--input', help="Input folder with PDBs", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_4_outputs")
+    parser.add_argument('--chains_to_design', help="Chains to design (space-separated)", default="A C")
+    parser.add_argument('--fixed_positions', help="Fixed positions for the chains", default="1 2 3 4 5 6 7 8 23 25, 10 11 12 13 14 15 16 17 18 19 20 40")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input folder with PDBs : {args.input}")
+    print(f"Chains to design: {args.chains_to_design}")
+
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+    path_for_assigned_chains = os.path.join(output_dir, "assigned_pdbs.jsonl")
+    path_for_fixed_positions = os.path.join(output_dir, "fixed_pdbs.jsonl")
+
+    # Run parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Assign chains to design
+    a = run([
+        'python', '../helper_scripts/assign_fixed_chains.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_assigned_chains,
+        '--chain_list', args.chains_to_design
+    ])
+    assert a.returncode == 0, "Error assigning fixed chains"
+
+    # Make fixed positions dictionary
+    a = run([
+        'python', '../helper_scripts/make_fixed_positions_dict.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_fixed_positions,
+        '--chain_list', args.chains_to_design,
+        '--position_list', args.fixed_positions
+    ])
+    assert a.returncode == 0, "Error making fixed positions dictionary"
+
+    # Run protein folding script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--chain_id_jsonl', path_for_assigned_chains,
+        '--fixed_positions_jsonl', path_for_fixed_positions,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_4_non_fixed.py b/examples/script_example_4_non_fixed.py
new file mode 100644
index 0000000..6674ad6
--- /dev/null
+++ b/examples/script_example_4_non_fixed.py
@@ -0,0 +1,80 @@
+#!/usr/bin/env python
+# encoding: utf-8
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run protein folding with non-fixed positions on specific chains")
+    parser.add_argument('--input', help="Input folder with PDBs", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_4_non_fixed_outputs")
+    parser.add_argument('--chains_to_design', help="Chains to design (space-separated)", default="A C")
+    parser.add_argument('--design_only_positions', help="Design only these positions", default="1 2 3 4 5 6 7 8 9 10, 3 4 5 6 7 8")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input data directory: {args.input}")
+    print(f"Chains to design: {args.chains_to_design}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+    path_for_assigned_chains = os.path.join(output_dir, "assigned_pdbs.jsonl")
+    path_for_fixed_positions = os.path.join(output_dir, "fixed_pdbs.jsonl")
+
+    # Run parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Assign chains to design
+    a = run([
+        'python', '../helper_scripts/assign_fixed_chains.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_assigned_chains,
+        '--chain_list', args.chains_to_design
+    ])
+    assert a.returncode == 0, "Error assigning fixed chains"
+
+    # Make non-fixed positions dictionary
+    a = run([
+        'python', '../helper_scripts/make_fixed_positions_dict.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_fixed_positions,
+        '--chain_list', args.chains_to_design,
+        '--position_list', args.design_only_positions,
+        '--specify_non_fixed'
+    ])
+    assert a.returncode == 0, "Error making non-fixed positions dictionary"
+
+    # Run protein folding script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--chain_id_jsonl', path_for_assigned_chains,
+        '--fixed_positions_jsonl', path_for_fixed_positions,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_5.py b/examples/script_example_5.py
new file mode 100644
index 0000000..487fbfe
--- /dev/null
+++ b/examples/script_example_5.py
@@ -0,0 +1,94 @@
+#!/usr/bin/env python
+# encoding: utf-8
+
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run ProteinMPNN pipeline with multiple chains and positions")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_5_outputs")
+    parser.add_argument('--chains_to_design', default="A C", help="Chains to design")
+    parser.add_argument('--fixed_positions', default="9 10 11 12 13 14 15 16 17 18 19 20 21 22 23, 10 11 18 19 20 22", help="Fixed positions for the chains")
+    parser.add_argument('--tied_positions', default="1 2 3 4 5 6 7 8, 1 2 3 4 5 6 7 8", help="Tied positions for the chains")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input directory: {args.input}")
+    print(f"Chains to design: {args.chains_to_design}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    # Paths for output files
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+    path_for_assigned_chains = os.path.join(output_dir, "assigned_pdbs.jsonl")
+    path_for_fixed_positions = os.path.join(output_dir, "fixed_pdbs.jsonl")
+    path_for_tied_positions = os.path.join(output_dir, "tied_pdbs.jsonl")
+
+    # Run the parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run the chain assignment script
+    a = run([
+        'python', '../helper_scripts/assign_fixed_chains.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_assigned_chains,
+        '--chain_list', args.chains_to_design
+    ])
+    assert a.returncode == 0, "Error assigning fixed chains"
+
+    # Run the fixed positions script
+    a = run([
+        'python', '../helper_scripts/make_fixed_positions_dict.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_fixed_positions,
+        '--chain_list', args.chains_to_design,
+        '--position_list', args.fixed_positions
+    ])
+    assert a.returncode == 0, "Error making fixed positions dict"
+
+    # Run the tied positions script
+    a = run([
+        'python', '../helper_scripts/make_tied_positions_dict.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_tied_positions,
+        '--chain_list', args.chains_to_design,
+        '--position_list', args.tied_positions
+    ])
+    assert a.returncode == 0, "Error making tied positions dict"
+
+    # Run the main ProteinMPNN script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--chain_id_jsonl', path_for_assigned_chains,
+        '--fixed_positions_jsonl', path_for_fixed_positions,
+        '--tied_positions_jsonl', path_for_tied_positions,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_6.py b/examples/script_example_6.py
new file mode 100644
index 0000000..3e0c614
--- /dev/null
+++ b/examples/script_example_6.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python
+# encoding: utf-8
+
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run ProteinMPNN pipeline with homooligomers and tied positions")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_homooligomers/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_6_outputs")
+    parser.add_argument('--homooligomer', type=int, default=1, help="Homooligomer flag")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.2, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input data directory: {args.input}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    # Paths for output files
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+    path_for_tied_positions = os.path.join(output_dir, "tied_pdbs.jsonl")
+    path_for_designed_sequences = os.path.join(output_dir, "temp_0.1")
+
+    # Run the parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run the tied positions script
+    a = run([
+        'python', '../helper_scripts/make_tied_positions_dict.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_tied_positions,
+        '--homooligomer', str(args.homooligomer)
+    ])
+    assert a.returncode == 0, "Error making tied positions dict"
+
+    # Run the main ProteinMPNN script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--tied_positions_jsonl', path_for_tied_positions,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_7.py b/examples/script_example_7.py
new file mode 100644
index 0000000..6dda7fb
--- /dev/null
+++ b/examples/script_example_7.py
@@ -0,0 +1,57 @@
+#!/usr/bin/env python
+# encoding: utf-8
+
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run ProteinMPNN pipeline for monomers")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_monomers/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_7_outputs")
+    parser.add_argument('--num_seq_per_target', type=int, default=1, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--unconditional_probs_only', type=int, default=1, help="Use unconditional probabilities only")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input data directory: {args.input}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    # Paths for output files
+    folder_with_pdbs = args.input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+
+    # Run the parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run the main ProteinMPNN script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--unconditional_probs_only', str(args.unconditional_probs_only),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_8.py b/examples/script_example_8.py
new file mode 100644
index 0000000..0c3b518
--- /dev/null
+++ b/examples/script_example_8.py
@@ -0,0 +1,68 @@
+#!/usr/bin/env python
+# encoding: utf-8
+
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run ProteinMPNN pipeline with amino acid bias")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_monomers/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_8_outputs")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--AA_list', default="D E H K N Q R S T W Y", help="List of amino acids")
+    parser.add_argument('--bias_list', default="1.39 1.39 1.39 1.39 1.39 1.39 1.39 1.39 1.39 1.39 1.39", help="Bias list for amino acids")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"Input data directory: {args.input}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    # Paths for output files
+    folder_with_pdbs = args.input
+    path_for_bias = os.path.join(output_dir, "bias_pdbs.jsonl")
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+
+    # Run the script to create amino acid bias
+    a = run([
+        'python', '../helper_scripts/make_bias_AA.py',
+        '--output_path', path_for_bias,
+        '--AA_list', args.AA_list,
+        '--bias_list', args.bias_list
+    ])
+    assert a.returncode == 0, "Error creating bias amino acid list"
+
+    # Run the parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run the main ProteinMPNN script
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--out_folder', output_dir,
+        '--bias_AA_jsonl', path_for_bias,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/examples/script_example_pssm.py b/examples/script_example_pssm.py
new file mode 100644
index 0000000..2be1b93
--- /dev/null
+++ b/examples/script_example_pssm.py
@@ -0,0 +1,85 @@
+#!/usr/bin/env python
+# encoding: utf-8
+
+import os
+from subprocess import run
+from argparse import ArgumentParser
+
+def main(argv):
+    # Argument parsing
+    parser = ArgumentParser(description="Run ProteinMPNN pipeline with PSSM inputs")
+    parser.add_argument('--pssm_input', help="PSSM input directory", default="/ProteinMPNN/inputs/PSSM_inputs")
+    parser.add_argument('--input', help="Input data directory", default="/ProteinMPNN/inputs/PDB_complexes/pdbs/")
+    parser.add_argument('--output', help="Output directory", default="/outputs/example_pssm_outputs")
+    parser.add_argument('--chains_to_design', default="A B", help="Chains to design")
+    parser.add_argument('--num_seq_per_target', type=int, default=2, help="Number of sequences per target")
+    parser.add_argument('--sampling_temp', type=float, default=0.1, help="Sampling temperature")
+    parser.add_argument('--seed', type=int, default=37, help="Random seed")
+    parser.add_argument('--batch_size', type=int, default=1, help="Batch size")
+    parser.add_argument('--pssm_multi', type=float, default=0.3, help="PSSM multiplier")
+    parser.add_argument('--pssm_bias_flag', type=int, default=1, help="PSSM bias flag")
+    parser.add_argument('--precision', choices=['float32', 'bfloat16'], default='float32', help="Precision type for calculations")
+    args = parser.parse_args()
+
+    # Print the input arguments for visibility
+    print(f"PSSM Input directory: {args.pssm_input}")
+    print(f"Input data directory: {args.input}")
+    # Check and create output directory if it doesn't exist
+    output_dir = args.output
+    if not os.path.exists(output_dir):
+        os.makedirs(output_dir)
+
+    # Paths for output files
+    folder_with_pdbs = args.input
+    pssm_input_path = args.pssm_input
+    path_for_parsed_chains = os.path.join(output_dir, "parsed_pdbs.jsonl")
+    path_for_assigned_chains = os.path.join(output_dir, "assigned_pdbs.jsonl")
+    pssm_output_path = os.path.join(output_dir, "pssm.jsonl")
+
+    # Run parsing script
+    a = run([
+        'python', '../helper_scripts/parse_multiple_chains.py',
+        '--input_path', folder_with_pdbs,
+        '--output_path', path_for_parsed_chains
+    ])
+    assert a.returncode == 0, "Error parsing multiple chains"
+
+    # Run assign fixed chains script
+    a = run([
+        'python', '../helper_scripts/assign_fixed_chains.py',
+        '--input_path', path_for_parsed_chains,
+        '--output_path', path_for_assigned_chains,
+        '--chain_list', args.chains_to_design
+    ])
+    assert a.returncode == 0, "Error assigning fixed chains"
+
+    # Run make PSSM input dictionary script
+    a = run([
+        'python', '../helper_scripts/make_pssm_input_dict.py',
+        '--jsonl_input_path', path_for_parsed_chains,
+        '--PSSM_input_path', pssm_input_path,
+        '--output_path', pssm_output_path
+    ])
+    assert a.returncode == 0, "Error creating PSSM input dictionary"
+
+    # Run the main ProteinMPNN script with PSSM
+    a = run([
+        'python', '../protein_mpnn_run.py',
+        '--jsonl_path', path_for_parsed_chains,
+        '--chain_id_jsonl', path_for_assigned_chains,
+        '--out_folder', output_dir,
+        '--num_seq_per_target', str(args.num_seq_per_target),
+        '--sampling_temp', str(args.sampling_temp),
+        '--seed', str(args.seed),
+        '--batch_size', str(args.batch_size),
+        '--pssm_jsonl', pssm_output_path,
+        '--pssm_multi', str(args.pssm_multi),
+        '--pssm_bias_flag', str(args.pssm_bias_flag),
+        '--precision', args.precision
+    ])
+    assert a.returncode == 0, "Error running protein folding script"
+
+if __name__ == "__main__":
+    import sys
+    main(sys.argv)
+
diff --git a/protein_mpnn_run.py b/protein_mpnn_run.py
index 27816ee..e76aa36 100644
--- a/protein_mpnn_run.py
+++ b/protein_mpnn_run.py
@@ -17,7 +17,7 @@ def main(args):
     import random
     import os.path
     import subprocess
-    
+
     from protein_mpnn_utils import loss_nll, loss_smoothed, gather_edges, gather_nodes, gather_nodes_t, cat_neighbors_nodes, _scores, _S_to_seq, tied_featurize, parse_PDB, parse_fasta
     from protein_mpnn_utils import StructureDataset, StructureDatasetPDB, ProteinMPNN
 
@@ -28,17 +28,17 @@ def main(args):
 
     torch.manual_seed(seed)
     random.seed(seed)
-    np.random.seed(seed)   
-    
+    np.random.seed(seed)
+
     hidden_dim = 128
-    num_layers = 3 
-  
+    num_layers = 3
+
 
     if args.path_to_model_weights:
         model_folder_path = args.path_to_model_weights
         if model_folder_path[-1] != '/':
             model_folder_path = model_folder_path + '/'
-    else: 
+    else:
         file_path = os.path.realpath(__file__)
         k = file_path.rfind("/")
         if args.ca_only:
@@ -56,16 +56,16 @@ def main(args):
 
     checkpoint_path = model_folder_path + f'{args.model_name}.pt'
     folder_for_outputs = args.out_folder
-    
+
     NUM_BATCHES = args.num_seq_per_target//args.batch_size
     BATCH_COPIES = args.batch_size
     temperatures = [float(item) for item in args.sampling_temp.split()]
     omit_AAs_list = args.omit_AAs
     alphabet = 'ACDEFGHIKLMNPQRSTVWYX'
-    alphabet_dict = dict(zip(alphabet, range(21)))    
-    print_all = args.suppress_print == 0 
+    alphabet_dict = dict(zip(alphabet, range(21)))
+    print_all = args.suppress_print == 0
     omit_AAs_np = np.array([AA in omit_AAs_list for AA in alphabet]).astype(np.float32)
-    device = torch.device("cuda:0" if (torch.cuda.is_available()) else "cpu")
+    device = torch.device("cpu")
     if os.path.isfile(args.chain_id_jsonl):
         with open(args.chain_id_jsonl, 'r') as json_file:
             json_list = list(json_file)
@@ -76,7 +76,7 @@ def main(args):
         if print_all:
             print(40*'-')
             print('chain_id_jsonl is NOT loaded')
-        
+
     if os.path.isfile(args.fixed_positions_jsonl):
         with open(args.fixed_positions_jsonl, 'r') as json_file:
             json_list = list(json_file)
@@ -87,8 +87,8 @@ def main(args):
             print(40*'-')
             print('fixed_positions_jsonl is NOT loaded')
         fixed_positions_dict = None
-    
-    
+
+
     if os.path.isfile(args.pssm_jsonl):
         with open(args.pssm_jsonl, 'r') as json_file:
             json_list = list(json_file)
@@ -100,8 +100,8 @@ def main(args):
             print(40*'-')
             print('pssm_jsonl is NOT loaded')
         pssm_dict = None
-    
-    
+
+
     if os.path.isfile(args.omit_AA_jsonl):
         with open(args.omit_AA_jsonl, 'r') as json_file:
             json_list = list(json_file)
@@ -112,8 +112,8 @@ def main(args):
             print(40*'-')
             print('omit_AA_jsonl is NOT loaded')
         omit_AA_dict = None
-    
-    
+
+
     if os.path.isfile(args.bias_AA_jsonl):
         with open(args.bias_AA_jsonl, 'r') as json_file:
             json_list = list(json_file)
@@ -124,8 +124,8 @@ def main(args):
             print(40*'-')
             print('bias_AA_jsonl is NOT loaded')
         bias_AA_dict = None
-    
-    
+
+
     if os.path.isfile(args.tied_positions_jsonl):
         with open(args.tied_positions_jsonl, 'r') as json_file:
             json_list = list(json_file)
@@ -137,11 +137,11 @@ def main(args):
             print('tied_positions_jsonl is NOT loaded')
         tied_positions_dict = None
 
-    
+
     if os.path.isfile(args.bias_by_res_jsonl):
         with open(args.bias_by_res_jsonl, 'r') as json_file:
             json_list = list(json_file)
-    
+
         for json_str in json_list:
             bias_by_res_dict = json.loads(json_str)
         if print_all:
@@ -151,16 +151,16 @@ def main(args):
             print(40*'-')
             print('bias by residue dictionary is not loaded, or not provided')
         bias_by_res_dict = None
-   
 
-    if print_all: 
+
+    if print_all:
         print(40*'-')
     bias_AAs_np = np.zeros(len(alphabet))
     if bias_AA_dict:
             for n, AA in enumerate(alphabet):
                     if AA in list(bias_AA_dict.keys()):
                             bias_AAs_np[n] = bias_AA_dict[AA]
-    
+
     if args.pdb_path:
         pdb_dict_list = parse_PDB(args.pdb_path, ca_only=args.ca_only)
         dataset_valid = StructureDatasetPDB(pdb_dict_list, truncate=None, max_length=args.max_length)
@@ -175,28 +175,32 @@ def main(args):
     else:
         dataset_valid = StructureDataset(args.jsonl_path, truncate=None, max_length=args.max_length, verbose=print_all)
 
-    checkpoint = torch.load(checkpoint_path, map_location=device) 
+    checkpoint = torch.load(checkpoint_path, map_location=device)
     noise_level_print = checkpoint['noise_level']
     model = ProteinMPNN(ca_only=args.ca_only, num_letters=21, node_features=hidden_dim, edge_features=hidden_dim, hidden_dim=hidden_dim, num_encoder_layers=num_layers, num_decoder_layers=num_layers, augment_eps=args.backbone_noise, k_neighbors=checkpoint['num_edges'])
     model.to(device)
     model.load_state_dict(checkpoint['model_state_dict'])
     model.eval()
+    if args.precision == 'bfloat16':
+        model = model.to(dtype=torch.bfloat16)
+    else:
+        model = model.to(dtype=torch.float32)
 
     if print_all:
         print(40*'-')
         print('Number of edges:', checkpoint['num_edges'])
         print(f'Training noise level: {noise_level_print}A')
- 
+
     # Build paths for experiment
     base_folder = folder_for_outputs
     if base_folder[-1] != '/':
         base_folder = base_folder + '/'
     if not os.path.exists(base_folder):
         os.makedirs(base_folder)
-    
+
     if not os.path.exists(base_folder + 'seqs'):
         os.makedirs(base_folder + 'seqs')
-    
+
     if args.save_score:
         if not os.path.exists(base_folder + 'scores'):
             os.makedirs(base_folder + 'scores')
@@ -204,7 +208,7 @@ def main(args):
     if args.score_only:
         if not os.path.exists(base_folder + 'score_only'):
             os.makedirs(base_folder + 'score_only')
-   
+
 
     if args.conditional_probs_only:
         if not os.path.exists(base_folder + 'conditional_probs_only'):
@@ -213,18 +217,25 @@ def main(args):
     if args.unconditional_probs_only:
         if not os.path.exists(base_folder + 'unconditional_probs_only'):
             os.makedirs(base_folder + 'unconditional_probs_only')
- 
+
     if args.save_probs:
         if not os.path.exists(base_folder + 'probs'):
-            os.makedirs(base_folder + 'probs') 
-    
+            os.makedirs(base_folder + 'probs')
+
     # Timing
     start_time = time.time()
     total_residues = 0
     protein_list = []
     total_step = 0
+    if args.precision == 'bfloat16':
+        dtype = torch.bfloat16
+        enabled = True
+        torch.set_default_dtype(dtype)
+    else:
+        dtype = torch.float32
+        enabled = False
     # Validation epoch
-    with torch.no_grad():
+    with torch.no_grad(), torch.autocast(enabled=enabled,dtype=dtype,device_type="cpu"):
         test_sum, test_weights = 0., 0.
         for ix, protein in enumerate(dataset_valid):
             score_list = []
@@ -237,7 +248,7 @@ def main(args):
             pssm_log_odds_mask = (pssm_log_odds_all > args.pssm_threshold).float() #1.0 for true, 0.0 for false
             name_ = batch_clones[0]['name']
             if args.score_only:
-                loop_c = 0 
+                loop_c = 0
                 if args.path_to_fasta:
                     fasta_names, fasta_seqs = parse_fasta(args.path_to_fasta, omit=["/"])
                     loop_c = len(fasta_seqs)
@@ -307,6 +318,8 @@ def main(args):
                 np.savez(unconditional_probs_only_file, log_p=concat_log_p, S=S[0,].cpu().numpy(), mask=mask[0,].cpu().numpy(), design_mask=mask_out)
             else:
                 randn_1 = torch.randn(chain_M.shape, device=X.device)
+                if args.precision == "bfloat16":
+                    mask = mask.to(torch.bfloat16)
                 log_probs = model(X, S, mask, chain_M*chain_M_pos, residue_idx, chain_encoding_all, randn_1)
                 mask_for_loss = mask*chain_M*chain_M_pos
                 scores = _scores(S, log_probs, mask_for_loss) #score only the redesigned part
@@ -326,7 +339,7 @@ def main(args):
                             randn_2 = torch.randn(chain_M.shape, device=X.device)
                             if tied_positions_dict == None:
                                 sample_dict = model.sample(X, randn_2, S, chain_M, chain_encoding_all, residue_idx, mask=mask, temperature=temp, omit_AAs_np=omit_AAs_np, bias_AAs_np=bias_AAs_np, chain_M_pos=chain_M_pos, omit_AA_mask=omit_AA_mask, pssm_coef=pssm_coef, pssm_bias=pssm_bias, pssm_multi=args.pssm_multi, pssm_log_odds_flag=bool(args.pssm_log_odds_flag), pssm_log_odds_mask=pssm_log_odds_mask, pssm_bias_flag=bool(args.pssm_bias_flag), bias_by_res=bias_by_res_all)
-                                S_sample = sample_dict["S"] 
+                                S_sample = sample_dict["S"]
                             else:
                                 sample_dict = model.tied_sample(X, randn_2, S, chain_M, chain_encoding_all, residue_idx, mask=mask, temperature=temp, omit_AAs_np=omit_AAs_np, bias_AAs_np=bias_AAs_np, chain_M_pos=chain_M_pos, omit_AA_mask=omit_AA_mask, pssm_coef=pssm_coef, pssm_bias=pssm_bias, pssm_multi=args.pssm_multi, pssm_log_odds_flag=bool(args.pssm_log_odds_flag), pssm_log_odds_mask=pssm_log_odds_mask, pssm_bias_flag=bool(args.pssm_bias_flag), tied_pos=tied_pos_list_of_lists_list[0], tied_beta=tied_beta, bias_by_res=bias_by_res_all)
                             # Compute scores
@@ -335,12 +348,12 @@ def main(args):
                             mask_for_loss = mask*chain_M*chain_M_pos
                             scores = _scores(S_sample, log_probs, mask_for_loss)
                             scores = scores.cpu().data.numpy()
-                            
+
                             global_scores = _scores(S_sample, log_probs, mask) #score the whole structure-sequence
                             global_scores = global_scores.cpu().data.numpy()
-                            
+
                             all_probs_list.append(sample_dict["probs"].cpu().data.numpy())
-                            all_log_probs_list.append(log_probs.cpu().data.numpy())
+                            all_log_probs_list.append(log_probs.float().cpu().data.numpy())
                             S_sample_list.append(S_sample.cpu().data.numpy())
                             for b_ix in range(BATCH_COPIES):
                                 masked_chain_length_list = masked_chain_length_list_list[b_ix]
@@ -389,7 +402,7 @@ def main(args):
                                     end += mask_l
                                     list_of_AAs.append(seq[start:end])
                                     start = end
-    
+
                                 seq = "".join(list(np.array(list_of_AAs)[np.argsort(masked_list)]))
                                 l0 = 0
                                 for mc_length in list(np.array(masked_chain_length_list)[np.argsort(masked_list)])[:-1]:
@@ -414,21 +427,21 @@ def main(args):
                 total_length = X.shape[1]
                 if print_all:
                     print(f'{num_seqs} sequences of length {total_length} generated in {dt} seconds')
-   
+
 if __name__ == "__main__":
     argparser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
 
     argparser.add_argument("--suppress_print", type=int, default=0, help="0 for False, 1 for True")
 
-  
-    argparser.add_argument("--ca_only", action="store_true", default=False, help="Parse CA-only structures and use CA-only models (default: false)")   
-    argparser.add_argument("--path_to_model_weights", type=str, default="", help="Path to model weights folder;") 
+
+    argparser.add_argument("--ca_only", action="store_true", default=False, help="Parse CA-only structures and use CA-only models (default: false)")
+    argparser.add_argument("--path_to_model_weights", type=str, default="", help="Path to model weights folder;")
     argparser.add_argument("--model_name", type=str, default="v_48_020", help="ProteinMPNN model name: v_48_002, v_48_010, v_48_020, v_48_030; v_48_010=version with 48 edges 0.10A noise")
     argparser.add_argument("--use_soluble_model", action="store_true", default=False, help="Flag to load ProteinMPNN weights trained on soluble proteins only.")
 
 
     argparser.add_argument("--seed", type=int, default=0, help="If set to 0 then a random seed will be picked;")
- 
+
     argparser.add_argument("--save_score", type=int, default=0, help="0 for False, 1 for True; save score=-log_prob to npy files")
     argparser.add_argument("--save_probs", type=int, default=0, help="0 for False, 1 for True; save MPNN predicted probabilites per position")
 
@@ -436,16 +449,16 @@ if __name__ == "__main__":
     argparser.add_argument("--path_to_fasta", type=str, default="", help="score provided input sequence in a fasta format; e.g. GGGGGG/PPPPS/WWW for chains A, B, C sorted alphabetically and separated by /")
 
 
-    argparser.add_argument("--conditional_probs_only", type=int, default=0, help="0 for False, 1 for True; output conditional probabilities p(s_i given the rest of the sequence and backbone)")    
-    argparser.add_argument("--conditional_probs_only_backbone", type=int, default=0, help="0 for False, 1 for True; if true output conditional probabilities p(s_i given backbone)") 
-    argparser.add_argument("--unconditional_probs_only", type=int, default=0, help="0 for False, 1 for True; output unconditional probabilities p(s_i given backbone) in one forward pass")   
- 
+    argparser.add_argument("--conditional_probs_only", type=int, default=0, help="0 for False, 1 for True; output conditional probabilities p(s_i given the rest of the sequence and backbone)")
+    argparser.add_argument("--conditional_probs_only_backbone", type=int, default=0, help="0 for False, 1 for True; if true output conditional probabilities p(s_i given backbone)")
+    argparser.add_argument("--unconditional_probs_only", type=int, default=0, help="0 for False, 1 for True; output unconditional probabilities p(s_i given backbone) in one forward pass")
+
     argparser.add_argument("--backbone_noise", type=float, default=0.00, help="Standard deviation of Gaussian noise to add to backbone atoms")
     argparser.add_argument("--num_seq_per_target", type=int, default=1, help="Number of sequences to generate per target")
     argparser.add_argument("--batch_size", type=int, default=1, help="Batch size; can set higher for titan, quadro GPUs, reduce this if running out of GPU memory")
     argparser.add_argument("--max_length", type=int, default=200000, help="Max sequence length")
     argparser.add_argument("--sampling_temp", type=str, default="0.1", help="A string of temperatures, 0.2 0.25 0.5. Sampling temperature for amino acids. Suggested values 0.1, 0.15, 0.2, 0.25, 0.3. Higher values will lead to more diversity.")
-    
+
     argparser.add_argument("--out_folder", type=str, help="Path to a folder to output sequences, e.g. /home/out/")
     argparser.add_argument("--pdb_path", type=str, default='', help="Path to a single PDB to be designed")
     argparser.add_argument("--pdb_path_chains", type=str, default='', help="Define which chains need to be designed for a single PDB ")
@@ -454,16 +467,17 @@ if __name__ == "__main__":
     argparser.add_argument("--fixed_positions_jsonl", type=str, default='', help="Path to a dictionary with fixed positions")
     argparser.add_argument("--omit_AAs", type=list, default='X', help="Specify which amino acids should be omitted in the generated sequence, e.g. 'AC' would omit alanine and cystine.")
     argparser.add_argument("--bias_AA_jsonl", type=str, default='', help="Path to a dictionary which specifies AA composion bias if neededi, e.g. {A: -1.1, F: 0.7} would make A less likely and F more likely.")
-   
-    argparser.add_argument("--bias_by_res_jsonl", default='', help="Path to dictionary with per position bias.") 
+
+    argparser.add_argument("--bias_by_res_jsonl", default='', help="Path to dictionary with per position bias.")
     argparser.add_argument("--omit_AA_jsonl", type=str, default='', help="Path to a dictionary which specifies which amino acids need to be omited from design at specific chain indices")
     argparser.add_argument("--pssm_jsonl", type=str, default='', help="Path to a dictionary with pssm")
     argparser.add_argument("--pssm_multi", type=float, default=0.0, help="A value between [0.0, 1.0], 0.0 means do not use pssm, 1.0 ignore MPNN predictions")
     argparser.add_argument("--pssm_threshold", type=float, default=0.0, help="A value between -inf + inf to restric per position AAs")
     argparser.add_argument("--pssm_log_odds_flag", type=int, default=0, help="0 for False, 1 for True")
     argparser.add_argument("--pssm_bias_flag", type=int, default=0, help="0 for False, 1 for True")
-    
+    argparser.add_argument("--precision", type=str, choices=["float32", "bfloat16"], help="Floating-point precision to use (float32 or bfloat16)")
+
     argparser.add_argument("--tied_positions_jsonl", type=str, default='', help="Path to a dictionary with tied positions")
-    
-    args = argparser.parse_args()    
-    main(args)   
+
+    args = argparser.parse_args()
+    main(args)
